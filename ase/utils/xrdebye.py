# flake8: noqa
"""Definition of the XrDebye class.

This module defines the XrDebye class for calculation
of X-ray scattering properties from atomic cluster
using Debye formula.
Also contains routine for calculation of atomic form factors and
X-ray wavelength dict.
"""

from math import exp, pi, sin, sqrt, cos, acos
import numpy as np
import matplotlib.pyplot as plt
from timeit import default_timer as timer
from ase.data import atomic_numbers, covalent_radii, colors
from copy import deepcopy

# Table (1) of
# D. WAASMAIER AND A. KIRFEL, Acta Cryst. (1995). A51, 416-431
#help from https://subversion.xray.aps.anl.gov/pyGSAS/trunk/FormFactors.py
waasmaier = {
     #       a1         b1         a2         b2        a3         b3        a4       b4         a5       b5         c
     'H': [0.413048, 15.569946, 0.294953, 32.398468, 0.187491, 5.711404, 0.080701, 61.889874, 0.023736, 1.334118, 0.000049],
    'He': [0.732354, 11.553918, 0.753896, 4.595831, 0.283819, 1.546299, 0.190003, 26.463964, 0.039139, 0.377523, 0.000487],
    'Li': [0.974637, 4.334946, 0.158472, 0.342451, 0.811855, 97.102966, 0.262416, 201.363831, 0.790108, 1.409234, 0.002542],
    'Be': [1.533712, 42.662079, 0.638283, 0.595420, 0.601052, 99.106499, 0.106139, 0.151340, 1.118414, 1.843093, 0.002511],
    'B': [2.085185, 23.494068, 1.064580, 1.137894, 1.062788, 61.238976, 0.140515, 0.114886, 0.641784, 0.399036, 0.003823],
    'C': [2.657506, 14.780758, 1.078079, 0.776775, 1.490909, 42.086842, -4.241070, -0.000294, 0.713791, 0.239535, 4.297983],
    'N': [11.893780, 0.000158, 3.277479, 10.232723, 1.858092, 30.344690, 0.858927, 0.656065, 0.912985, 0.217287, -11.804900],
    'O': [2.960427, 14.182259, 2.508818, 5.936858, 0.637853, 0.112726, 0.722838, 34.958481, 1.142756, 0.390240, 0.027014],
    'F': [3.511943, 10.687859, 2.772244, 4.380466, 0.678385, 0.093982, 0.915159, 27.255203, 1.089261, 0.313066, 0.032557],
    'Ne': [4.183749, 8.175457, 2.905726, 3.252536, 0.520513, 0.063295, 1.135641, 21.813910, 1.228065, 0.224952, 0.025576],
    'Na': [4.910127, 3.281434, 3.081783, 9.119178, 1.262067, 0.102763, 1.098938, 132.013947, 0.560991, 0.405878, 0.079712],
    'Mg': [4.708971, 4.875207, 1.194814, 108.506081, 1.558157, 0.111516, 1.170413, 48.292408, 3.239403, 1.928171, 0.126842],
    'Al': [4.730796, 3.628931, 2.313951, 43.051167, 1.541980, 0.095960, 1.117564, 108.932388, 3.154754, 1.555918, 0.139509],
    'Si': [5.275329, 2.631338, 3.191038, 33.730728, 1.511514, 0.081119, 1.356849, 86.288643, 2.519114, 1.170087, 0.145073],
    'P': [1.950541, 0.908139, 4.146930, 27.044952, 1.494560, 0.071280, 1.522042, 67.520187, 5.729711, 1.981173, 0.155233],
    'S': [6.372157, 1.514347, 5.154568, 22.092527, 1.473732, 0.061373, 1.635073, 55.445175, 1.209372, 0.646925, 0.154722],
    'Cl': [1.446071, 0.052357, 6.870609, 1.193165, 6.151801, 18.343416, 1.750347, 46.398396, 0.634168, 0.401005, 0.146773],
    'Ar': [7.188004, 0.956221, 6.638454, 15.339877, 0.454180, 15.339862, 1.929593, 39.043823, 1.523654, 0.062409, 0.265954],
    'K': [8.163991, 12.816323, 7.146945, 0.808945, 1.070140, 210.327011, 0.877316, 39.597652, 1.486434, 0.052821, 0.253614],
    'Ca': [8.593655, 10.460644, 1.477324, 0.041891, 1.436254, 81.390381, 1.182839, 169.847839, 7.113258, 0.688098, 0.196255],
    'Sc': [1.476566, 53.131023, 1.487278, 0.035325, 1.600187, 137.319489, 9.177463, 9.098031, 7.099750, 0.602102, 0.157765],
    'Ti': [9.818524, 8.001879, 1.522646, 0.029763, 1.703101, 39.885422, 1.768774, 120.157997, 7.082555, 0.532405, 0.102473],
    'V': [10.473575, 7.081940, 1.547881, 0.026040, 1.986381, 31.909672, 1.865616, 108.022842, 7.056250, 0.474882, 0.067744],
    'Cr': [11.007069, 6.366281, 1.555477, 0.023987, 2.985293, 23.244839, 1.347855, 105.774498, 7.034779, 0.429369, 0.065510],
    'Mn': [11.709542, 5.597120, 1.733414, 0.017800, 2.673141, 21.788420, 2.023368, 89.517914, 7.003180, 0.383054, -0.147293],
    'Fe': [12.311098, 5.009415, 1.876623, 0.014461, 3.066177, 18.743040, 2.070451, 82.767876, 6.975185, 0.346506, -0.304931],
    'Co': [12.914510, 4.507138, 2.481908, 0.009126, 3.466894, 16.438129, 2.106351, 76.987320, 6.960892, 0.314418, -0.936572],
    'Ni': [13.521865, 4.077277, 6.947285, 0.286763, 3.866028, 14.622634, 2.135900, 71.966080, 4.284731, 0.004437, -2.762697],
    'Cu': [14.014192, 3.738280, 4.784577, 0.003744, 5.056806, 13.034982, 1.457971, 72.554794, 6.932996, 0.265666, -3.254477],
    'Zn': [14.741002, 3.388232, 6.907748, 0.243315, 4.642337, 11.903689, 2.191766, 63.312130, 38.424042, 0.000397, -36.915829],
    'Ga': [15.758946, 3.121754, 6.841123, 0.226057, 4.121016, 12.482196, 2.714681, 66.203621, 2.395246, 0.007238, -0.847395],
    'Ge': [16.540613, 2.866618, 1.567900, 0.012198, 3.727829, 13.432163, 3.345098, 58.866047, 6.785079, 0.210974, 0.018726],
    'As': [17.025642, 2.597739, 4.503441, 0.003012, 3.715904, 14.272119, 3.937200, 50.437996, 6.790175, 0.193015, -2.984117],
    'Se': [17.354071, 2.349787, 4.653248, 0.002550, 4.259489, 15.579460, 4.136455, 45.181202, 6.749163, 0.177432, -3.160982],
    'Br': [17.550570, 2.119226, 5.411882, 16.557184, 3.937180, 0.002481, 3.880645, 42.164009, 6.707793, 0.162121, -2.492088],
    'Kr': [17.655279, 1.908231, 6.848105, 16.606236, 4.171004, 0.001598, 3.446760, 39.917473, 6.685200, 0.146896, -2.810592],
    'Rb': [8.123134, 15.142385, 2.138042, 33.542667, 6.761702, 0.129372, 1.156051, 224.132507, 17.679546, 1.713368, 1.139548],
    'Sr': [17.730219, 1.563060, 9.795867, 14.310868, 6.099763, 0.120574, 2.620025, 135.771317, 0.600053, 0.120574, 1.140251],
    'Y': [17.792040, 1.429691, 10.253252, 13.132816, 5.714949, 0.112173, 3.170516, 108.197029, 0.918251, 0.112173, 1.131787],
    'Zr': [17.859772, 1.310692, 10.911038, 12.319285, 5.821115, 0.104353, 3.512513, 91.777542, 0.746965, 0.104353, 1.124859],
    'Nb': [17.958399, 1.211590, 12.063054, 12.246687, 5.007015, 0.098615, 3.287667, 75.011948, 1.531019, 0.098615, 1.123452],
    'Mo': [6.236218, 0.090780, 17.987711, 1.108310, 12.973127, 11.468720, 3.451426, 66.684151, 0.210899, 0.090780, 1.108770],
    'Tc': [17.840963, 1.005729, 3.428236, 41.901382, 1.373012, 119.320541, 12.947364, 9.781542, 6.335469, 0.083391, 1.074784],
    'Ru': [6.271624, 0.077040, 17.906738, 0.928222, 14.123269, 9.555345, 3.746008, 35.860680, 0.908235, 123.552246, 1.043992],
    'Rh': [6.216648, 0.070789, 17.919739, 0.856121, 3.854252, 33.889484, 0.840326, 121.686691, 15.173498, 9.029517, 0.995452],
    'Pd': [6.121511, 0.062549, 4.784063, 0.784031, 16.631683, 8.751391, 4.318258, 34.489983, 13.246773, 0.784031, 0.883099],
    'Ag': [6.073874, 0.055333, 17.155437, 7.896512, 4.173344, 28.443739, 0.852238, 110.376106, 17.988686, 0.716809, 0.756603],
    'Cd': [6.080986, 0.048990, 18.019468, 7.273646, 4.018197, 29.119284, 1.303510, 95.831207, 17.974669, 0.661231, 0.603504],
    'In': [6.196477, 0.042072, 18.816183, 6.695665, 4.050479, 31.009790, 1.638929, 103.284348, 17.962912, 0.610714, 0.333097],
    'Sn': [19.325171, 6.118104, 6.281571, 0.036915, 4.498866, 32.529045, 1.856934, 95.037186, 17.917318, 0.565651, 0.119024],
    'Sb': [5.394956, 33.326523, 6.549570, 0.030974, 19.650681, 5.564929, 1.827820, 87.130966, 17.867832, 0.523992, -0.290506],
    'Te': [6.660302, 33.031654, 6.940756, 0.025750, 19.847015, 5.065547, 1.557175, 84.101616, 17.802427, 0.487660, -0.806668],
    'I': [19.884502, 4.628591, 6.736593, 0.027754, 8.110516, 31.849096, 1.170953, 84.406387, 17.548716, 0.463550, -0.448811],
    'Xe': [19.978920, 4.143356, 11.774945, 0.010142, 9.332182, 28.796200, 1.244749, 75.280685, 17.737501, 0.413616, -6.065902],
    'Cs': [17.418674, 0.399828, 8.314444, 0.016872, 10.323193, 25.605827, 1.383834, 233.339676, 19.876251, 3.826915, -2.322802],
    'Ba': [19.747343, 3.481823, 17.368477, 0.371224, 10.465718, 21.226641, 2.592602, 173.834274, 11.003653, 0.010719, -5.183497],
    'La': [19.966019, 3.197408, 27.329655, 0.003446, 11.018425, 19.955492, 3.086696, 141.381973, 17.335455, 0.341817, -21.745489],
    'Ce': [17.355122, 0.328369, 43.988499, 0.002047, 20.546650, 3.088196, 3.130670, 134.907654, 11.353665, 18.832960, -38.386017],
    'Pr': [21.551311, 2.995675, 17.161730, 0.312491, 11.903859, 17.716705, 2.679103, 152.192825, 9.564197, 0.010468, -3.871068],
    'Nd': [17.331244, 0.300269, 62.783924, 0.001320, 12.160097, 17.026001, 2.663483, 148.748993, 22.239950, 2.910268, -57.189842],
    'Pm': [17.286388, 0.286620, 51.560162, 0.001550, 12.478557, 16.223755, 2.675515, 143.984512, 22.960947, 2.796480, -45.973682],
    'Sm': [23.700363, 2.689539, 23.072214, 0.003491, 12.777782, 15.495437, 2.684217, 139.862473, 17.204367, 0.274536, -17.452166],
    'Eu': [17.186195, 0.261678, 37.156837, 0.001995, 13.103387, 14.787360, 2.707246, 134.816299, 24.419271, 2.581883, -31.586687],
    'Gd': [24.898117, 2.435028, 17.104952, 0.246961, 13.222581, 13.996325, 3.266152, 110.863091, 48.995213, 0.001383, -43.505684],
    'Tb': [25.910013, 2.373912, 32.344139, 0.002034, 13.765117, 13.481969, 2.751404, 125.836510, 17.064405, 0.236916, -26.851971],
    'Dy': [26.671785, 2.282593, 88.687576, 0.000665, 14.065445, 12.920230, 2.768497, 121.937187, 17.067781, 0.225531, -83.279831],
    'Ho': [27.150190, 2.169660, 16.999819, 0.215414, 14.059334, 12.213148, 3.386979, 100.506783, 46.546471, 0.001211, -41.165253],
    'Er': [28.174887, 2.120995, 82.493271, 0.000640, 14.624002, 11.915256, 2.802756, 114.529938, 17.018515, 0.207519, -77.135223],
    'Tm': [28.925894, 2.046203, 76.173798, 0.000656, 14.904704, 11.465375, 2.814812, 111.411980, 16.998117, 0.199376, -70.839813],
    'Yb': [29.676760, 1.977630, 65.624069, 0.000720, 15.160854, 11.044622, 2.830288, 108.139153, 16.997850, 0.192110, -60.313812],
    'Lu': [30.122866, 1.883090, 15.099346, 10.342764, 56.314899, 0.000780, 3.540980, 89.559250, 16.943729, 0.183849, -51.049416],
    'Hf': [30.617033, 1.795613, 15.145351, 9.934469, 54.933548, 0.000739, 4.096253, 76.189705, 16.896156, 0.175914, -49.719837],
    'Ta': [31.066359, 1.708732, 15.341823, 9.618455, 49.278297, 0.000760, 4.577665, 66.346199, 16.828321, 0.168002, -44.119026],
    'W': [31.507900, 1.629485, 15.682498, 9.446448, 37.960129, 0.000898, 4.885509, 59.980675, 16.792112, 0.160798, -32.864574],
    'Re': [31.888456, 1.549238, 16.117104, 9.233474, 42.390297, 0.000689, 5.211669, 54.516373, 16.767591, 0.152815, -37.412682],
    'Os': [32.210297, 1.473531, 16.678440, 9.049695, 48.559906, 0.000519, 5.455839, 50.210201, 16.735533, 0.145771, -43.677956],
    'Ir': [32.004436, 1.353767, 1.975454, 81.014175, 17.070105, 0.128093, 15.939454, 7.661196, 5.990003, 26.659403, 4.018893],
    'Pt': [31.273891, 1.316992, 18.445440, 8.797154, 17.063745, 0.124741, 5.555933, 40.177994, 1.575270, 1.316997, 4.050394],
    'Au': [16.777390, 0.122737, 19.317156, 8.621570, 32.979683, 1.256902, 5.595453, 38.008820, 10.576854, 0.000601, -6.279078],
    'Hg': [16.839890, 0.115905, 20.023823, 8.256927, 28.428564, 1.195250, 5.881564, 39.247227, 4.714706, 1.195250, 4.076478],
    'Tl': [16.630795, 0.110704, 19.386616, 7.181401, 32.808571, 1.119730, 1.747191, 90.660263, 6.356862, 26.014978, 4.066939],
    'Pb': [16.419567, 0.105499, 32.738590, 1.055049, 6.530247, 25.025890, 2.342742, 80.906593, 19.916475, 6.664449, 4.049824],
    'Bi': [16.282274, 0.101180, 32.725136, 1.002287, 6.678302, 25.714146, 2.694750, 77.057549, 20.576559, 6.291882, 4.040914],
    'Po': [16.289164, 0.098121, 32.807171, 0.966265, 21.095163, 6.046622, 2.505901, 76.598068, 7.254589, 28.096128, 4.046556],
    'At': [16.011461, 0.092639, 32.615547, 0.904416, 8.113899, 26.543257, 2.884082, 68.372963, 21.377867, 5.499512, 3.995684],
    'Rn': [16.070229, 0.090437, 32.641106, 0.876409, 21.489658, 5.239687, 2.299218, 69.188477, 9.480184, 27.632641, 4.020977],
    'Fr': [16.007385, 0.087031, 32.663830, 0.840187, 21.594351, 4.954467, 1.598497, 199.805801, 11.121192, 26.905106, 4.003472],
    'Ra': [32.563690, 0.801980, 21.396671, 4.590666, 11.298093, 22.758972, 2.834688, 160.404388, 15.914965, 0.083544, 3.981773],
    'Ac': [15.914053, 0.080511, 32.535042, 0.770669, 21.553976, 4.352206, 11.433394, 21.381622, 3.612409, 130.500748, 3.939212],
    'Th': [15.784024, 0.077067, 32.454899, 0.735137, 21.849222, 4.097976, 4.239077, 109.464111, 11.736191, 20.512138, 3.922533],
    'Pa': [32.740208, 0.709545, 21.973675, 4.050881, 12.957398, 19.231543, 3.683832, 117.255005, 15.744058, 0.074040, 3.886066],
    'U': [15.679275, 0.071206, 32.824306, 0.681177, 13.660459, 18.236156, 3.687261, 112.500038, 22.279434, 3.930325, 3.854444],
    'Np': [32.999901, 0.657086, 22.638077, 3.854918, 14.219973, 17.435474, 3.672950, 109.464485, 15.683245, 0.068033, 3.769391],
    'Pu': [33.281178, 0.634999, 23.148544, 3.856168, 15.153755, 16.849735, 3.031492, 121.292038, 15.704215, 0.064857, 3.664200],
    'Am': [33.435162, 0.612785, 23.657259, 3.792942, 15.576339, 16.195778, 3.027023, 117.757004, 15.746100, 0.061755, 3.541160],
    'Cm': [15.804837, 0.058619, 33.480801, 0.590160, 24.150198, 3.674720, 3.655563, 100.736191, 15.499866, 15.408296, 3.390840],
    'Bk': [15.889072, 0.055503, 33.625286, 0.569571, 24.710381, 3.615472, 3.707139, 97.694786, 15.839268, 14.754303, 3.213169],
    'Cf': [33.794075, 0.550447, 25.467693, 3.581973, 16.048487, 14.357388, 3.657525, 96.064972, 16.008982, 0.052450, 3.005326],
    'H1-': [0.702260, 23.945604, 0.763666, 74.897919, 0.248678, 6.773289, 0.261323, 233.583450, 0.023017, 1.337000, 0.000425],
    'Li1+': [0.432724, 0.260367, 0.549257, 1.042836, 0.376575, 7.885294, -0.336481, 0.260368, 0.976060, 3.042000, 0.001764],
    'Be2+': [3.055430, 0.001226, -2.372617, 0.001227, 1.044914, 1.542106, 0.544233, 0.456279, 0.381737, 4.047000, -0.653773],
    'Cval': [1.258489, 10.683769, 0.728215, 0.208177, 1.119856, 0.836097, 2.168133, 24.603704, 0.705239, 58.954000, 0.019722],
    'O1-': [3.106934, 19.868080, 3.235142, 6.960252, 1.148886, 0.170043, 0.783981, 65.693512, 0.676953, 0.630000, 0.046136],
    'O2-': [3.990247, 16.639956, 2.300563, 5.636819, 0.607200, 0.108493, 1.907882, 47.299709, 1.167080, 0.379000, 0.025429],
    'F1-': [0.457649, 0.917243, 3.841561, 5.507803, 1.432771, 0.164955, 0.801876, 51.076206, 3.395041, 15.821000, 0.069525],
    'Na1+': [3.148690, 2.594987, 4.073989, 6.046925, 0.767888, 0.070139, 0.995612, 14.122657, 0.968249, 0.217000, 0.045300],
    'Mg2+': [3.062918, 2.015803, 4.135106, 4.417941, 0.853742, 0.065307, 1.036792, 9.669710, 0.852520, 0.187000, 0.058851],
    'Al3+': [4.132015, 3.528641, 0.912049, 7.378344, 1.102425, 0.133708, 0.614876, 0.039065, 3.219136, 1.644000, 0.019397],
    'Siva': [2.879033, 1.239713, 3.072960, 38.706276, 1.515981, 0.081481, 1.390030, 93.616333, 4.995051, 2.770000, 0.146030],
    'Si4+': [3.676722, 1.446851, 3.828496, 3.013144, 1.258033, 0.064397, 0.419024, 0.206254, 0.720421, 5.970000, 0.097266],
    'Cl1-': [1.061802, 0.144727, 7.139886, 1.171795, 6.524271, 19.467655, 2.355626, 60.320301, 35.829403, 0.000000, -34.916603],
    'K1+': [-17.609339, 18.840979, 1.494873, 0.053453, 7.150305, 0.812940, 10.899569, 22.264105, 15.808228, 14.351000, 0.257164],
    'Ca2+': [8.501441, 10.525848, 12.880483, -0.004033, 9.765095, 0.010692, 7.156669, 0.684443, 0.711160, 27.231000, -21.013187],
    'Sc3+': [7.104348, 0.601957, 1.511488, 0.033386, -53.669773, 12.572138, 38.404816, 10.859736, 24.532240, 14.125000, 0.118642],
    'Ti2+': [7.040119, 0.537072, 1.496285, 0.031914, 9.657304, 8.009958, 0.006534, 201.800293, 1.649561, 24.039000, 0.150362],
    'Ti3+': [36.587933, 0.000681, 7.230255, 0.522262, -9.086077, 5.262317, 2.084594, 15.881716, 17.294008, 6.149000, -35.111282],
    'Ti4+': [45.355537, 9.252186, 7.092900, 0.523046, 7.483858, 13.082852, -43.498817, 10.193876, 1.678915, 0.023000, -0.110628],
    'V2+': [7.754356, 7.066315, 2.064100, 0.014993, 2.576998, 7.066308, 2.011404, 22.055786, 7.126177, 0.467000, -0.533379],
    'V3+': [9.958480, 6.763041, 1.596350, 0.056895, 1.483442, 17.750029, -10.846044, 0.328826, 17.332867, 0.388000, 0.474921],
    'V5+': [15.575018, 0.682708, 8.448095, 5.566640, 1.612040, 10.527077, -9.721855, 0.907961, 1.534029, 0.066000, 0.552676],
    'Cr2+': [10.598877, 6.151846, 1.565858, 0.023519, 2.728280, 17.432816, 0.098064, 54.002388, 6.959321, 0.426000, 0.049870],
    'Cr3+': [7.989310, 6.068867, 1.765079, 0.018342, 2.627125, 6.068887, 1.829380, 16.309284, 6.980908, 0.420000, -0.192123],
    'Mn2+': [11.287712, 5.506225, 26.042414, 0.000774, 3.058096, 16.158575, 0.090258, 54.766354, 7.088306, 0.375000, -24.566132],
    'Mn3+': [6.926972, 0.378315, 2.081342, 0.015054, 11.128379, 5.379957, 2.375107, 14.429586, -0.419287, 0.004000, -0.093713],
    'Mn4+': [12.409131, 0.300400, 7.466993, 0.112814, 1.809947, 12.520756, -12.138477, 0.168653, 10.780248, 5.173000, 0.672146],
    'Fe2+': [11.776765, 4.912232, 11.165097, 0.001748, 3.533495, 14.166556, 0.165345, 42.381958, 7.036932, 0.341000, -9.676919],
    'Fe3+': [9.721638, 4.869297, 63.403847, 0.000293, 2.141347, 4.867602, 2.629274, 13.539076, 7.033846, 0.338000, -61.930725],
    'Co2+': [6.993840, 0.310779, 26.285812, 0.000684, 12.254289, 4.400528, 0.246114, 35.741447, 4.017407, 12.536000, -24.796852],
    'Co3+': [6.861739, 0.309794, 2.678570, 0.008142, 12.281889, 4.331703, 3.501741, 11.914167, -0.179384, 11.914000, -1.147345],
    'Ni2+': [12.519017, 3.933053, 37.832058, 0.000442, 4.387257, 10.449184, 0.661552, 23.860998, 6.949072, 0.283000, -36.344471],
    'Ni3+': [13.579366, 0.313140, 1.902844, 0.012621, 12.859268, 3.906407, 3.811005, 10.894311, -6.838595, 0.344000, -0.317618],
    'Cu1+': [12.960763, 3.576010, 16.342150, 0.000975, 1.110102, 29.523218, 5.520682, 10.114283, 6.915452, 0.261000, -14.849320],
    'Cu2+': [11.895569, 3.378519, 16.344978, 0.000924, 5.799817, 8.133653, 1.048804, 20.526524, 6.789088, 0.254000, -14.878383],
    'Zn2+': [13.340772, 3.215913, 10.428857, 0.001413, 5.544489, 8.542680, 0.762295, 21.891756, 6.869172, 0.239000, -8.945248],
    'Ga3+': [13.123875, 2.809960, 35.288189, 0.000323, 6.126979, 6.831534, 0.611551, 16.784311, 6.724807, 0.212000, -33.875122],
    'Ge4+': [6.876636, 2.025174, 6.779091, 0.176650, 9.969591, 3.573822, 3.135857, 7.685848, 0.152389, 16.677000, 1.086540],
    'Br1-': [17.714310, 2.122554, 6.466926, 19.050768, 6.947385, 0.152708, 4.402674, 58.690361, -0.697279, 58.690000, 1.152674],
    'Rb1+': [17.684320, 1.710209, 7.761588, 14.919863, 6.680874, 0.128542, 2.668883, 31.654478, 0.070974, 0.128000, 1.133263],
    'Sr2+': [17.694973, 1.550888, 1.275762, 30.133041, 6.154252, 0.118774, 9.234786, 13.821799, 0.515995, 0.118000, 1.125309],
    'Y3+': [46.660366, -0.019971, 10.369686, 13.180257, 4.623042, 0.176398, -62.170834, -0.016727, 17.471146, 1.467000, 19.023842],
    'Zr4+': [6.802956, 0.096228, 17.699253, 1.296127, 10.650647, 11.240715, -0.248108, -0.219259, 0.250338, -0.219000, 0.827902],
    'Nb3+': [17.714323, 1.172419, 1.675213, 30.102791, 7.483963, 0.080255, 8.322464, -0.002983, 11.143573, 10.456000, -8.339573],
    'Nb5+': [17.580206, 1.165852, 7.633277, 0.078558, 10.793497, 9.507652, 0.180884, 31.621656, 67.837921, -0.000000, -68.024780],
    'Mo3+': [7.447050, 0.072000, 17.778122, 1.073145, 11.886068, 9.834720, 1.997905, 28.221746, 1.789626, -0.011000, -1.898764],
    'Mo5+': [7.929879, 0.068856, 17.667669, 1.068064, 11.515987, 9.046229, 0.500402, 26.558945, 77.444084, -0.000000, -78.056595],
    'Mo6+': [34.757683, 1.301770, 9.653037, 7.123843, 6.584769, 0.094097, -18.628115, 1.617443, 2.490594, 12.335000, 1.141916],
    'Ru3+': [17.894758, 0.902827, 13.579529, 8.740579, 10.729251, 0.045125, 2.474095, 24.764954, 48.227997, -0.001000, -51.905243],
    'Ru4+': [17.845776, 0.901070, 13.455084, 8.482392, 10.229087, 0.045972, 1.653524, 23.015272, 14.059795, -0.004000, -17.241762],
    'Rh3+': [17.758621, 0.841779, 14.569813, 8.319533, 5.298320, 0.069050, 2.533579, 23.709131, 0.879753, 0.069000, 0.960843],
    'Rh4+': [17.716188, 0.840572, 14.446654, 8.100647, 5.185801, 0.068995, 1.703448, 22.357307, 0.989992, 0.068000, 0.959941],
    'Pd2+': [6.122282, 0.062424, 15.651012, 8.018296, 3.513508, 24.784275, 9.060790, 0.776457, 8.771199, 0.776000, 0.879336],
    'Pd4+': [6.152421, -0.063951, -96.069023, -11.090354, -31.622141, -13.466152, -81.578255, -9.758302, -17.801403, -0.783000, -0.915874],
    'Ag1+': [6.091192, 0.056305, 4.019526, 0.719340, 16.948174, 7.758938, 4.258638, 27.368349, 13.889437, 0.719000, 0.785127],
    'Ag2+': [6.401808, 0.068167, 48.699802, 0.942270, 4.799859, 20.639496, -32.332523, 1.100365, 16.356710, 6.883000, 1.068247],
    'Cd2+': [6.093711, 0.050624, 43.909691, 8.654143, 17.041306, 15.621396, -39.675117, 11.082067, 17.958918, 0.667000, 0.664795],
    'In3+': [6.206277, 0.041357, 18.497746, 6.605563, 3.078131, 18.792250, 10.524613, 0.608082, 7.401234, 0.608000, 0.293677],
    'Sn2+': [6.353672, 0.034720, 4.770377, 6.167891, 14.672025, 6.167879, 4.235959, 29.006456, 18.002131, 0.561000, -0.042519],
    'Sn4+': [15.445732, 6.280898, 6.420892, 0.033144, 4.562980, 6.280899, 1.713385, 17.983601, 18.033537, 0.557000, -0.172219],
    'Sb3+': [10.189171, 0.089485, 57.461918, 0.375256, 19.356573, 5.357987, 4.862206, 22.153736, -45.394096, 0.297000, 1.516108],
    'Sb5+': [17.920622, 0.522315, 6.647932, 0.029487, 12.724075, 5.718210, 1.555545, 16.433775, 7.600591, 5.718000, -0.445371],
    'I1-': [20.010330, 4.565931, 17.835524, 0.444266, 8.104130, 32.430672, 2.231118, 95.149040, 9.158548, 0.014000, -3.341004],
    'Cs1+': [19.939056, 3.770511, 24.967621, 0.004040, 10.375884, 25.311275, 0.454243, 76.537766, 17.660248, 0.384000, -19.394306],
    'Ba2+': [19.750200, 3.430748, 17.513683, 0.361590, 10.884892, 21.358307, 0.321585, 70.309402, 65.149834, 0.001000, -59.618172],
    'La3+': [19.688887, 3.146211, 17.345703, 0.339586, 11.356296, 18.753832, 0.099418, 90.345459, 82.358124, 0.001000, -76.846909],
    'Ce3+': [26.593231, 3.280381, 85.866432, 0.001012, -6.677695, 4.313575, 12.111847, 17.868504, 17.401903, 0.326000, -80.313423],
    'Ce4+': [17.457533, 0.311812, 25.659941, -0.003793, 11.691037, 16.568687, 19.695251, 2.886395, -16.994749, -0.008000, -3.515096],
    'Pr3+': [20.879841, 2.870897, 36.035797, 0.002364, 12.135341, 16.615236, 0.283103, 53.909359, 17.167803, 0.306000, -30.500784],
    'Pr4+': [17.496082, 0.294457, 21.538509, -0.002742, 20.403114, 2.772886, 12.062211, 15.804613, -7.492043, -0.013000, -9.016722],
    'Nd3+': [17.120077, 0.291295, 56.038139, 0.001421, 21.468307, 2.743681, 10.000671, 14.581367, 2.905866, 22.485000, -50.541992],
    'Pm3+': [22.221066, 2.635767, 17.068142, 0.277039, 12.805423, 14.927315, 0.435687, 45.768017, 52.238770, 0.001000, -46.767181],
    'Sm3+': [15.618565, 0.006001, 19.538092, 0.306379, 13.398946, 14.979594, -4.358811, 0.748825, 24.490461, 2.454000, -9.714854],
    'Eu2+': [23.899035, 2.467332, 31.657497, 0.002230, 12.955752, 13.625002, 1.700576, 35.089481, 16.992199, 0.253000, -26.204315],
    'Eu3+': [17.758327, 0.244474, 33.498665, -0.003901, 24.067188, 2.487526, 13.436883, 14.568011, -9.019134, -0.015000, -19.768026],
    'Gd3+': [24.344999, 2.333971, 16.945311, 0.239215, 13.866931, 12.982995, 0.481674, 43.876347, 93.506378, 0.000000, -88.147179],
    'Tb3+': [24.878252, 2.223301, 16.856016, 0.227290, 13.663937, 11.812528, 1.279671, 29.910065, 39.271294, 0.001000, -33.950317],
    'Dy3+': [16.864344, 0.216275, 90.383461, 0.000593, 13.675473, 11.121207, 1.687078, 26.250975, 25.540651, 2.135000, -85.150650],
    'Ho3+': [16.837524, 0.206873, 63.221336, 0.000796, 13.703766, 10.500283, 2.061602, 24.031883, 26.202621, 2.055000, -58.026505],
    'Er3+': [16.810127, 0.198293, 22.681061, 0.002126, 13.864114, 9.973341, 2.294506, 22.836388, 26.864477, 1.979000, -17.513460],
    'Tm3+': [16.787500, 0.190852, 15.350905, 0.003036, 14.182357, 9.602934, 2.299111, 22.526880, 27.573771, 1.912000, -10.192087],
    'Yb2+': [28.443794, 1.863896, 16.849527, 0.183811, 14.165081, 9.225469, 3.445311, 23.691355, 28.308853, 0.001000, -23.214935],
    'Yb3+': [28.191629, 1.842889, 16.828087, 0.182788, 14.167848, 9.045957, 2.744962, 20.799847, 23.171774, 0.001000, -18.103676],
    'Lu3+': [28.828693, 1.776641, 16.823227, 0.175560, 14.247617, 8.575531, 3.079559, 19.693701, 25.647667, 0.001000, -20.626528],
    'Hf4+': [29.267378, 1.697911, 16.792543, 0.168313, 14.785310, 8.190025, 2.184128, 18.277578, 23.791996, 0.001000, -18.820383],
    'Ta5+': [29.539469, 1.612934, 16.741854, 0.160460, 15.182070, 7.654408, 1.642916, 17.070732, 16.437447, 0.001000, -11.542459],
    'W6+': [29.729357, 1.501648, 17.247808, 0.140803, 15.184488, 6.880573, 1.154652, 14.299601, 0.739335, 14.299000, 3.945157],
    'Os4+': [17.113485, 0.131850, 15.792370, 7.288542, 23.342392, 1.389307, 4.090271, 19.629425, 7.671292, 1.389000, 3.988390],
    'Ir3+': [31.537575, 1.334144, 16.363338, 7.451918, 15.597141, 0.127514, 5.051404, 21.705648, 1.436935, 0.127000, 4.009459],
    'Ir4+': [30.391249, 1.328519, 16.146996, 7.181766, 17.019068, 0.127337, 4.458904, 19.060146, 0.975372, 1.328000, 4.006865],
    'Pt2+': [31.986849, 1.281143, 17.249048, 7.625512, 15.269374, 0.123571, 5.760234, 24.190826, 1.694079, 0.123000, 4.032512],
    'Pt4+': [41.932713, 1.111409, 16.339224, 6.466086, 17.653894, 0.128917, 6.012420, 16.954155, -12.036877, 0.778000, 4.094551],
    'Au1+': [32.124306, 1.216073, 16.716476, 7.165378, 16.814100, 0.118715, 7.311565, 20.442486, 0.993064, 53.095000, 4.040792],
    'Au3+': [31.704271, 1.215561, 17.545767, 7.220506, 16.819551, 0.118812, 5.522640, 20.050970, 0.361725, 1.215000, 4.042679],
    'Hg1+': [28.866837, 1.173967, 19.277540, 7.583842, 16.776051, 0.115351, 6.281459, 29.055994, 3.710289, 1.173000, 4.068430],
    'Hg2+': [32.411079, 1.162980, 18.690371, 7.329806, 16.711773, 0.114518, 9.974835, 22.009489, -3.847611, 22.009000, 4.052869],
    'Tl1+': [32.295044, 1.101544, 16.570049, 0.110020, 17.991013, 6.528559, 1.535355, 52.495068, 7.554591, 20.338000, 4.054030],
    'Tl3+': [32.525639, 1.094966, 19.139185, 6.900992, 17.100321, 0.103667, 5.891115, 18.489614, 12.599463, -0.001000, -9.256075],
    'Pb2+': [27.392647, 1.058874, 16.496822, 0.106305, 19.984501, 6.708123, 6.813923, 24.395554, 5.233910, 1.058000, 4.065623],
    'Pb4+': [32.505657, 1.047035, 20.014240, 6.670321, 14.645661, 0.105279, 5.029499, 16.525040, 1.760138, 0.105000, 4.044678],
    'Bi3+': [32.461437, 0.997930, 19.438683, 6.038867, 16.302486, 0.101338, 7.322662, 18.371586, 0.431704, 46.361000, 4.043703],
    'Bi5+': [16.734028, 0.105076, 20.580494, 4.773282, 9.452623, 11.762162, 61.155834, 1.211775, -34.041023, 1.619000, 4.113663],
    'Ra2+': [4.986228, 0.082597, 32.474945, 0.791468, 21.947443, 4.608034, 11.800013, 24.792431, 10.807292, 0.082000, 3.956572],
    'Ac3+': [15.584983, 0.077438, 32.022125, 0.739963, 21.456327, 4.040735, 0.757593, 47.525002, 12.341252, 19.406000, 3.838984],
    'Th4+': [15.515445, 0.074499, 32.090691, 0.711663, 13.996399, 3.871044, 12.918157, 18.596891, 7.635514, 3.871000, 3.831122],
    'U3+': [15.360309, 0.067815, 32.395657, 0.654643, 21.961290, 3.643409, 1.325894, 39.604965, 14.251453, 16.330000, 3.706622],
    'U4+': [15.355091, 0.067789, 32.235306, 0.652613, 0.557745, 42.354237, 14.396367, 15.908239, 21.751173, 3.553000, 3.705863],
    'U6+': [15.333844, 0.067644, 31.770849, 0.646384, 21.274414, 3.317894, 13.872636, 14.650250, 0.048519, 75.339000, 3.700591],
    'Np3+': [15.378152, 0.064613, 32.572132, 0.631420, 22.206125, 3.561936, 1.413295, 37.875511, 14.828381, 15.546000, 3.603370],
    'Np4+': [15.373926, 0.064597, 32.423019, 0.629658, 21.969994, 3.476389, 0.662078, 39.438942, 14.969350, 15.135000, 3.603039],
    'Np6+': [15.359986, 0.064528, 31.992825, 0.624505, 21.412458, 3.253441, 0.066574, 67.658318, 14.568174, 13.980000, 3.600942],
    'Pu3+': [15.356004, 0.060590, 32.769127, 0.604663, 22.680210, 3.491509, 1.351055, 37.260635, 15.416232, 14.981000, 3.428895],
    'Pu4+': [15.416219, 0.061456, 32.610569, 0.607938, 22.256662, 3.411848, 0.719495, 37.628792, 15.518152, 14.464000, 3.480408],
    'Pu6+': [15.436506, 0.061815, 32.289719, 0.606541, 14.726737, 3.245363, 15.012391, 13.616438, 7.024677, 3.245000, 3.502325],
}

#more here: https://x-server.gmca.aps.anl.gov/cgi/www_dbli.exe?x0hdb=waves
wavelengths = {
    'CuKa1': 1.5405981,
    'CuKa2': 1.54443,
    'CuKb1': 1.39225,
    'CrKa1': 2.28973,
    'CrKa2': 2.293606,
    'WLa1': 1.47642,
    'WLa2': 1.48748
}


class XrDebye:
    """
    Class for calculation of XRD or SAXS patterns.
    """
    def __init__(self, atoms, wavelength, damping=0.04,
                 method='Iwasa', alpha=1.01, warn=True):
        """
        Initilize the calculation of X-ray diffraction patterns

        Parameters:

        atoms: ase.Atoms
            atoms object for which calculation will be performed.

        wavelength: float, Angstrom
            X-ray wavelength in Angstrom. Used for XRD and to setup dumpings.

        damping : float, Angstrom**2
            thermal damping factor parameter (B-factor).

        method: {'Iwasa'}
            method of calculation (damping and atomic factors affected).

            If set to 'Iwasa' than angular damping and q-dependence of
            atomic factors are used.

            For any other string there will be only thermal damping
            and constant atomic factors (`f_a(q) = Z_a`).

        alpha: float
            parameter for angular damping of scattering intensity.
            Close to 1.0 for unplorized beam.

        warn: boolean
            flag to show warning if atomic factor can't be calculated
        """
        self.wavelength = wavelength
        self.damping = damping
        self.mode = ''
        self.method = method
        self.alpha = alpha
        self.warn = warn

        self.twotheta_list = []
        self.q_list = []
        self.intensity_list = []

        self.atoms = atoms
        # TODO: setup atomic form factors if method != 'Iwasa'
        
        #for indexing peaks
        self.hkl = {}
        self.cartesian_transform = None
        self.miller_transform = None
        self.unit_cell_atom_positions = None
        self.atoms_unit_cell = None
        self.atoms_extended_unit_cell = None
        
        return None

    def set_damping(self, damping):
        """ set B-factor for thermal damping """
        self.damping = damping
        return None
    
    def get_interatomic_distances(self, verbose=False):
        pos = self.atoms.get_positions() #positions of atoms
        #manage memory consumption by reducing the resolution for large atomic arrays
        if(len(self.atoms) > 1e4):
            precision = np.float32
        else:
            precision = np.float64
        interatomic_distance = np.zeros((len(self.atoms),len(self.atoms)),dtype=precision)
        
        #can the distance calculation be parallelized? It ran much slower with multiprocess.Pool.map
        for i in range(len(self.atoms)):
            rel_positions = pos - pos[i] #x, y, and z distance difference
            interatomic_distance[i,:] = np.sqrt(np.sum(rel_positions * rel_positions, axis=1)) #euclidean distance between atoms
            
        if verbose:
            print('Precision: ',precision, ' , number of atoms:', len(self.atoms), ' , max distance:', np.max(interatomic_distance),'angstrom')
            
        return interatomic_distance
    
    def get_symbols(self, atoms):
        symbols = []
        for a in atoms:
            symbol_charge = a.symbol
            if(a.charge<0):
                symbol_charge+=(str("{:1d}".format(int(abs(a.charge))))+'-')
            elif(a.charge>0):
                symbol_charge+=(str("{:1d}".format(int(a.charge)))+'+')
            symbols.append(symbol_charge)
        return symbols
    
    def get_thermal_damping(self,s):
        #damping = exp(-B*q^2/2), s = Q/(2pi), q^2/2 = (s^2)*4*pi^2/2
        pre = exp(-self.damping * s**2 * 2 * np.pi**2)#thermal damping, self.damping is a squared term, b^2
        
        if self.method == 'Iwasa':
            #https://pubs.acs.org/doi/10.1021/jp063532w
            sinth = self.wavelength * s /2. #sin(theta)
            positive = 1 - sinth**2
            if positive < 0:
                positive = 0
            costh = sqrt(positive)
            cos2th = cos(2. * acos(costh))
            pre *= costh / (1. + self.alpha * costh**2) #correct for angular dependence
        return pre
    
    def get_unique_atomic_form_factors(self, s, unique_symbols):
        """
        get atomic form factor, using cache.
        """
        f = {}
        for symbol in unique_symbols:
            if symbol not in f:
                if self.method == 'Iwasa':
                    f[symbol] = self.get_waasmaier(symbol, s)
                else:
                    f[symbol] = atomic_numbers[symbol]
        return f

    def get(self, s):
        r"""Get the powder x-ray (XRD) scattering intensity
        using the Debye-Formula at single point.

        Parameters:

        s: float, in inverse Angstrom
            scattering vector value (`s = q / 2\pi`).

        Returns:
            Intensity at given scattering vector `s`.
        """

        pre = exp(-self.damping * s**2 / 2)

        if self.method == 'Iwasa':
            sinth = self.wavelength * s / 2.
            positive = 1. - sinth**2
            if positive < 0:
                positive = 0
            costh = sqrt(positive)
            cos2th = cos(2. * acos(costh))
            pre *= costh / (1. + self.alpha * cos2th**2)

        f = {}
        def atomic(symbol):
            """
            get atomic factor, using cache.
            """
            if symbol not in f:
                if self.method == 'Iwasa':
                    f[symbol] = self.get_waasmaier(symbol, s)
                else:
                    f[symbol] = atomic_numbers[symbol]
            return f[symbol]

        I = 0.
        fa = []  # atomic factors list
        for a in self.atoms:
            fa.append(atomic(a.symbol))

        pos = self.atoms.get_positions()  # positions of atoms
        fa = np.array(fa)  # atomic factors array

        for i in range(len(self.atoms)):
            vr = pos - pos[i]
            I += np.sum(fa[i] * fa * np.sinc(2 * s * np.sqrt(np.sum(vr * vr, axis=1))))

        return pre * I

    def get_waasmaier(self, symbol, s):
        r"""Scattering factor for free atoms.

        Parameters:

        symbol: string
            atom element symbol.

        s: float, in inverse Angstrom
            scattering vector value (`s = q / 2\pi`).

        Returns:
            Intensity at given scattering vector `s`.

        Note:
            for hydrogen will be returned zero value."""
        # if symbol == 'H':
            # # XXXX implement analytical H
            # return 0
        if symbol in waasmaier:
            #https://onlinelibrary.wiley.com/doi/epdf/10.1107/S0108767394013292?sentby=iucr
            #https://subversion.xray.aps.anl.gov/pyGSAS/trunk/FormFactors.py
            # f0[k] = c + [SUM a_i*EXP(-b_i*(k^2)) ]                                  
            #             i=1,5                                                       
            #                                                                          
            #  where k = sin(theta) / lambda, a_i, b_i and c are from the lookup table
            #  k = Q/(4pi)
            #  s = Q/(2pi) = 2*k
            abc = waasmaier[symbol]
            f = abc[10]
            s2 = s * s
            k2 = s2 / 4
            for i in range(5):
                f += abc[2 * i] * exp(-abc[2 * i + 1] * k2)
            return f
        if self.warn:
            print('<xrdebye::get_atomic> Element', symbol, 'not available')
        return 0

    def calc_pattern(self, x=None, mode='XRD', verbose=False, brute_force=False, plot_histograms=False):
        r"""
        Calculate X-ray diffraction pattern or
        small angle X-ray scattering pattern.

        Parameters:

        x: float array
            points where intensity will be calculated.
            XRD - 2theta values, in degrees;
            SAXS - q values in 1/A
            (`q = 2 \pi \cdot s = 4 \pi \sin( \theta) / \lambda`).
            If ``x`` is ``None`` then default values will be used.

        mode: {'XRD', 'SAXS'}
            the mode of calculation: X-ray diffraction (XRD) or
            small-angle scattering (SAXS).
            
        brute_force: bool
            if true, explicitly calculate intensity for every atomic pair
            if false, use a histogram approximation of the pdf to speed up the calculation
            
        plot_histograms: bool
            if true, and brute_force==false, then plot the interatomic histograms that are used in the calculation
            you need to externally call plt.show()

        Returns:
            list of intensities calculated for values given in ``x``.
        """
        #note; speed suffers from memory use and copy times (especially for parallelization, if improperly implemented), 
        #so I simplified the use of class variables and function calls to reduce memory use 
        start = timer()
        
        self.mode = mode.upper()
        assert(mode in ['XRD', 'SAXS'])

        result = []
        s = []
        if mode == 'XRD':
            if x is None:
                self.twotheta_list = np.linspace(15, 55, 100)
            else:
                self.twotheta_list = x
            self.q_list = []
            s = np.array([2 * sin(twotheta * pi / 180 / 2.0) / self.wavelength for twotheta in self.twotheta_list])
        elif mode == 'SAXS':
            if x is None:
                self.twotheta_list = np.logspace(-3, -0.3, 100)
            else:
                self.q_list = x
            self.twotheta_list = []
            s = np.array([q / (2 * pi) for q in self.q_list])    
        
        symbols_of_all_atoms = self.get_symbols(self.atoms)#get the array of symbols for all atoms
        #we may want histograms separated for each atomic pair  
        #according to the Theory 2.1 section of: https://doi.org/10.1107/S2052252521000324
        unique_symbols = list(set(symbols_of_all_atoms))#slim this down to the unique symbols
        interatomic_distances = self.get_interatomic_distances(verbose)#this is a big array, and takes a long time to calculate
        if verbose:
            end = timer() - start
            print(end, ' sec elapsed: finished calculating interatomic distances')
            
        #I couldn't make improvements with parallelization, so I removed the distance calculation from the loop
        #per Debye: I = sum*sum {f*f * sin(Q*r)/(Q*r)}
        #we can use sinc(x) = sin(pi*x)/(pi*x)
        #Q = (4pi/lambda)*sin(theta)
        #s = 2 * sin(2theta * pi/180/2)/wavelength = q/(2pi)
        #thus, pi*x = Q*r = 2*pi*s*r => x = 2*s*r
        if brute_force:
            #use the brute_force method
            if verbose:
                print('Now proceeding with brute force calculation of scattering')
            
            scattering_intensity = []
            for scattering_vector in s:
                thermal_coef = self.get_thermal_damping(scattering_vector)
                f = self.get_unique_atomic_form_factors(scattering_vector, unique_symbols)#get the set of form factors for unique species
                fa = [] #atomic form factor list
                for symbol in symbols_of_all_atoms:
                    fa.append(f[symbol])
                fa = np.array(fa) #atomic form factor array
            
                I = 0.
                for i in range(len(self.atoms)): #this is a big loop, calculating for every atom vs every other atom
                    I += np.sum(fa[i] * fa * np.sinc(2 * scattering_vector * interatomic_distances[i]))
                I *= thermal_coef
                scattering_intensity.append(I)
            
        else:
            #use the histogram method
            if verbose:
                print('Now calculating interatomic distance histograms...')
                
            #we should be careful about calculating bins and bin centers - choosing the same number of bins as num(atoms) has enough resolution
            #to capture the probability density function of the distances, but makes large arrays and slows the process down.
            #The auto-generated bin edges from the numpy library compute fast, but are too close together to properly capture the PDF; these require
            #correction to the mean of the values in each bin to fix truncation errors.
            histogram_bins = np.histogram_bin_edges(interatomic_distances,bins='auto')#bins=len(self.atoms)
            if verbose:
                end = timer() - start
                print(end, ' sec elapsed: finished finding histogram bin edges. Now putting pairs into bins...')
            histogram_bin_indices = np.digitize(interatomic_distances, bins=histogram_bins) #find the bin index, another slow process
            if verbose:
                end = timer() - start
                print(end, ' sec elapsed: finished finding histogram bin indices. Now separating atomic pairs...')
                
            I = np.zeros(len(s))
            for i in range(len(unique_symbols)):
                for j in range(i,len(unique_symbols)):
                    maski = [symbol == unique_symbols[i] for symbol in symbols_of_all_atoms]
                    maskj = [symbol == unique_symbols[j] for symbol in symbols_of_all_atoms]
                    mask = np.ix_(maski,maskj)
                    symbol_pair_bin_numbers = np.reshape(histogram_bin_indices[mask],-1)
                    symbol_pair_distances = np.reshape(interatomic_distances[mask],-1)
                    
                    #copy some functions from scipy.binned_statistics to quickly calculate the count in each bin and the mean of values in each bin
                    interatomic_distance_histogram_counts = np.bincount(symbol_pair_bin_numbers, None)
                    a = interatomic_distance_histogram_counts.nonzero()#indices of non-zero histogram bins, where we'll calculate mean distances
                    flatsum = np.bincount(symbol_pair_bin_numbers, symbol_pair_distances)
                    interatomic_distance_histogram_bin_centers = np.zeros(len(interatomic_distance_histogram_counts))#initialize the 'mean of bin values' array
                    interatomic_distance_histogram_bin_centers[a] = flatsum[a] / interatomic_distance_histogram_counts[a] #and repopulate only where the denominator is non-zero
                    
                    #plotting these histograms slows things down
                    if plot_histograms:
                        bin_widths = np.diff(histogram_bins)[0]
                        fig,ax = plt.subplots()
                        ax.bar(interatomic_distance_histogram_bin_centers, height=interatomic_distance_histogram_counts, width=bin_widths)
                        ax.set_xlabel('Interatomic distance [$\AA$]')
                        ax.set_ylabel('Count')
                        plt.title(unique_symbols[i]+unique_symbols[j])
            
                    if verbose:
                        end = timer() - start
                        print(end, ' sec elapsed: finished calculating interatomic distance histogram:' + unique_symbols[i]+unique_symbols[j])
                        
                    for k in range(len(s)):
                        scattering_vector = s[k]
                        f = self.get_unique_atomic_form_factors(scattering_vector, unique_symbols)
                        double_sum_symmetry = 1
                        if(j>i):
                            double_sum_symmetry = 2 #so we don't have to loop over every a-b AND b-a pair
                        fafb = f[unique_symbols[i]] * f[unique_symbols[j]]
                        I[k] += fafb*np.sum( double_sum_symmetry * interatomic_distance_histogram_counts * np.sinc(2 * scattering_vector * interatomic_distance_histogram_bin_centers) )
                        
            for k in range(len(s)):
                scattering_vector = s[k]
                thermal_coef = self.get_thermal_damping(scattering_vector)
                I[k] *= thermal_coef
            scattering_intensity = I
            
        self.intensity_list = np.array(scattering_intensity)
        if verbose:
            end = timer() - start
            print(end, ' sec elapsed: calculation complete')
            
        return self.intensity_list

    def write_pattern(self, filename):
        """ Save calculated data to file specified by ``filename`` string."""
        with open(filename, 'w') as fd:
            self._write_pattern(fd)

    def _write_pattern(self, fd):
        fd.write('# Wavelength = %f\n' % self.wavelength)
        if self.mode == 'XRD':
            x, y = self.twotheta_list, self.intensity_list
            fd.write('# 2theta \t Intesity\n')
        elif self.mode == 'SAXS':
            x, y = self.q_list, self.intensity_list
            fd.write('# q(1/A)\tIntesity\n')
        else:
            raise Exception('No data available, call calc_pattern() first.')

        for i in range(len(x)):
            fd.write('  %f\t%f\n' % (x[i], y[i]))

    def plot_pattern(self, filename=None, show=False, ax=None):
        """ Plot XRD or SAXS depending on filled data

        Uses Matplotlib to plot pattern. Use *show=True* to
        show the figure and *filename='abc.png'* or
        *filename='abc.eps'* to save the figure to a file.

        Returns:
            ``matplotlib.axes.Axes`` object."""

        import matplotlib.pyplot as plt

        if ax is None:
            plt.clf()  # clear figure
            ax = plt.gca()

        if self.mode == 'XRD':
            x, y = np.array(self.twotheta_list), np.array(self.intensity_list)
            ax.plot(x, y / np.max(y), '.-')
            ax.set_xlabel('2$\\theta$')
            ax.set_ylabel('Intensity')
        elif self.mode == 'SAXS':
            x, y = np.array(self.q_list), np.array(self.intensity_list)
            ax.loglog(x, y / np.max(y), '.-')
            ax.set_xlabel('q, 1/Angstr.')
            ax.set_ylabel('Intensity')
        else:
            raise Exception('No data available, call calc_pattern() first')

        if show:
            plt.show()
        if filename is not None:
            fig = ax.get_figure()
            fig.savefig(filename)

        return ax
    
    def d_bragg(self, angle_2theta, n=1):
        #calculate the d-spacing based on the angle and integer index
        #use bragg's law to calculate d-spacing
        #input 2-theta in degrees
        #nL = 2dsin(th)
        return n*self.wavelength/(2*np.sin((angle_2theta/2)*np.pi/180)) #in units of wavelength, which are usually angstrom
    
    def th_bragg(self, d_spacing, n=1):
        #calculate the scattering angle (2-theta) based on d-spacing and integer index
        #2-theta is returned in degrees
        return np.arcsin(n*self.wavelength/(2*d_spacing)) * 2 * 180/np.pi #in units of degrees
    
    def calc_hkl(self, unit_cell_atoms, plot_planes=False):
        self.atoms_unit_cell = unit_cell_atoms
        self.cartesian_transform = self.calculate_cartesian_transform()
        self.miller_transform = self.calculate_miller_transform()
        self.unit_cell_atom_positions = self.atoms_unit_cell.get_positions()
        self.atoms_extended_unit_cell = self.repeat_positions_on_unit_cell_edges()
        
        a,b,c = self.atoms_unit_cell.get_cell().lengths()
        recip = self.atoms_unit_cell.get_cell().reciprocal()
        a_,b_,c_ = recip.lengths()
        al_,be_,ga_ = recip.angles()*np.pi/180
        d_min = self.d_bragg(np.max(self.twotheta_list))#limited by the measurement
        d_max = self.d_bragg(np.min(self.twotheta_list))
        
        h_min,k_min,l_min = np.round((-1/d_min)*np.array([a,b,c]),0)
        h_max,k_max,l_max = np.abs(np.array([h_min,k_min,l_min]))
        h_range = np.arange(h_max,h_min-1,-1,dtype=np.int)
        k_range = np.arange(k_max,k_min-1,-1,dtype=np.int)
        l_range = np.arange(l_max,l_min-1,-1,dtype=np.int)
        hkl = {}
        for h in h_range:
            for k in k_range:
                for l in l_range:
                    
                    index_string = str(h)+' '+str(k)+' ' +str(l)
                    inv_d_sq = (h**2 * a_**2) + (k**2 * b_**2) + (l**2 * c_**2) + (2*k*l*b_*c_*np.cos(al_)) + (2*h*l*a_*c_*np.cos(be_)) + (2*h*k*a_*b_*np.cos(ga_))
                    if(inv_d_sq != 0):
                        d = 1/(np.sqrt(inv_d_sq))
                        if((d >= d_min) & (d <= d_max)):
                            plane_is_populated = self.plane_is_populated(h,k,l,d,plot_planes)#this allows one to distinguish between diffraction peaks that come from 'n' multiples and those that come from populated planes
                            F_mag,F = self.structure_factor(h,k,l,d)#this takes care of systematic absences
                            if(F_mag != 0):
                                twoTh = self.th_bragg(d)
                                hkl[index_string] = [d,twoTh,F,plane_is_populated,np.array([h,k,l]),[]]#d_spacing, 2theta, multiplicity/or/structure factor, flag_is_populated, (hkl), list of planes with same d-spacing
                                #print(d,index_string,F)
                                
        #reduce indices with the same d-spacing
        for key,item in list(hkl.items()):
            d_spacings = np.array([item[0] for key,item in hkl.items()])
            keys = np.array(list(hkl.keys()))
            d_spacing_mask = np.array([np.isclose(item[0], d_spac) for d_spac in d_spacings])
            keys_with_same_d_spacing = keys[d_spacing_mask]
            
            #prioritize key with smallest sum of abs() indices, and sum of number of negative indices
            hkl_sums = np.array([np.sum(np.abs(hkl[selected_key][4])) for selected_key in keys_with_same_d_spacing])
            hkl_neg = np.array([np.count_nonzero(hkl[selected_key][4]<0) for selected_key in keys_with_same_d_spacing])
            
            priority_key = keys_with_same_d_spacing[np.argmin(hkl_sums+hkl_neg)]
            
            #F_sum = np.absolute(np.sum(np.array([hkl[selected_key][2] for selected_key in keys_with_same_d_spacing])))
            #print(item[0], priority_key, F_sum, keys_with_same_d_spacing, hkl_sums, hkl_neg)
            for key_to_remove in keys_with_same_d_spacing:
                if(key_to_remove != priority_key):
                    hkl[priority_key][2] = len(keys_with_same_d_spacing)#include the multiplicity
                    hkl[priority_key][5] = list(keys_with_same_d_spacing)#write all the keys we're deleting
                    del hkl[key_to_remove]
        
        #print(len(hkl))
        self.hkl = hkl
        return None
    
    def get_hkl_string(self, hkl, index_type=None):
        #take the h,k, and l numbers an return a string with bars over negative numbers
        hkl_string = ''
        if(index_type=='plane'):
            hkl_string+='('
        elif(index_string=='family'):
            hkl_string+='{'
        elif(index_string=='direction'):
            hkl_string+='['
            
        def add_bar(num_string):
            new_string = ''
            for char in num_string:
                new_string+=char+'\u0305'
            return new_string
        
        h = hkl[0]
        k = hkl[1]
        l = hkl[2]
        h_string = str(np.abs(h))
        if(h<0):
            h_string = add_bar(h_string)
        k_string = str(np.abs(k))
        if(k<0):
            k_string = add_bar(k_string)
        l_string = str(np.abs(l))
        if(l<0):
            l_string = add_bar(l_string)
            
        hkl_string += h_string+k_string+l_string
        
        if(index_type=='plane'):
            hkl_string+=')'
        elif(index_string=='family'):
            hkl_string+='}'
        elif(index_string=='direction'):
            hkl_string+=']'
            
        return hkl_string
    
    def plot_indices(self,ax=None):
        if(ax==None):
            fig,ax = plt.subplots()
        two_theta = [item[1] for key,item in self.hkl.items()]
        bar_height = 0.95
        ax.bar(two_theta, height=bar_height, width=0.2, color='k')
        ax.set_xlabel('2\u03B8 [\N{Degree Sign}]')
        for key,item in self.hkl.items():
            x = item[1]
            y = bar_height
            is_populated = item[3]
            c = 'k'
            if(not is_populated):
                c = 'r'
            ax.annotate(self.get_hkl_string(item[4], index_type='plane'), xy=(x,y), xytext=(x, y+0.02), textcoords='data',fontsize=10,color=c,rotation=90)
            
        return ax
    
    def calculate_cartesian_transform(self):
        #calculate a transformation matrix using cell properties
        #use this matrix and miller - fractional coordinates to get cartesian coords.
        a,b,c = self.atoms_unit_cell.get_cell().lengths()
        alpha,beta,gamma = self.atoms_unit_cell.get_cell().angles()*np.pi/180
        omega = a*b*c*np.sqrt(1-np.cos(alpha)**2 - np.cos(beta)**2 - np.cos(gamma)**2 + 2*np.cos(alpha)*np.cos(beta)*np.cos(gamma))
        
        #transform to cartesian coordinates
        #https://en.wikipedia.org/wiki/Fractional_coordinates
        return np.array([[a, b*np.cos(gamma), c*np.cos(beta)], [0, b*np.sin(gamma), c*(np.cos(alpha)-np.cos(beta)*np.cos(gamma))/(np.sin(gamma))], [0, 0, omega/(a*b*np.sin(gamma))]])
    
    def calculate_miller_transform(self):
        #calculate a transform matrix using cell properties
        #use this matrix and cartesian coordinates to get fractional-miller coords.
        a,b,c = self.atoms_unit_cell.get_cell().lengths()
        alpha,beta,gamma = self.atoms_unit_cell.get_cell().angles()*np.pi/180
        omega = a*b*c*np.sqrt(1-np.cos(alpha)**2 - np.cos(beta)**2 - np.cos(gamma)**2 + 2*np.cos(alpha)*np.cos(beta)*np.cos(gamma))
        
        #transform to cartesian coordinates
        #https://en.wikipedia.org/wiki/Fractional_coordinates
        return np.array([[1/a, -np.cos(gamma)/(a*np.sin(gamma)), b*c*(np.cos(alpha)*np.cos(gamma)-np.cos(beta))/(omega*np.sin(gamma))], [0, 1/(b*np.sin(gamma)), a*c*(np.cos(beta)*np.cos(gamma)-np.cos(alpha))/(omega*np.sin(gamma))], [0, 0, a*b*np.sin(gamma)/omega]])
    
    def calculate_cartesian_indices(self,miller_indices):
        #calculate the cartesian equivalent of miller indices
        if(np.ndim(miller_indices) > 1):
            return np.array([self.cartesian_transform@indices for indices in miller_indices])
        else:
            return self.cartesian_transform@miller_indices #x,y,z
        
    def calculate_miller_indices(self, cartesian_indices):
        #calculate the miller-fractional equivalent of the cartesian indices
        if(np.ndim(cartesian_indices) > 1):
            return np.array([self.miller_transform@indices for indices in cartesian_indices])
        else:
            return self.miller_transform@cartesian_indices #(h,k,l)
        
    def calculate_cartesian_plane_norm(self, miller_indices):
        #calculate the normal vector for a plane based on miller indices, in cartesian units
        
        zero_indices = np.argwhere(miller_indices==0)
        
        #find two vectors in the plane, in miller notation
        qr = np.array([0,0,0])
        rs = np.array([0,0,0])
        if(len(zero_indices) >= 2):
            #the plane is parallel to two axes
            qr[zero_indices[0]] = 1
            rs[zero_indices[1]] = 1
        elif(len(zero_indices) == 1):
            #the plane is parallel to one axis
            qr[zero_indices[0]] = 1
            #we need to get the axis intercepts for the other two
            pts = np.array([[0,0,0],[0,0,0]],dtype=np.float64)
            pts_index = 0
            for i in range(len(miller_indices)):
                if(miller_indices[i] != 0):
                    pts[pts_index,i] = 1/miller_indices[i]
                    pts_index += 1
            rs = pts[0] - pts[1]
        else:
            #the plane is not parallel to any axis, so we will find the vectors from three points
            pts = np.array([[0,0,0],[0,0,0],[0,0,0]],dtype=np.float64)
            for i in range(len(miller_indices)):
                if(miller_indices[i] != 0):
                    pts[i,i] = 1/miller_indices[i]
            rs = pts[0] - pts[1]
            qr = pts[1] - pts[2]
            
        #print(miller_indices, zero_indices, qr, rs)
        
        #convert to cartesian coordinates
        rs_cart = self.calculate_cartesian_indices(rs)
        qr_cart = self.calculate_cartesian_indices(qr)
        tol = 1e-10
        rs_cart[np.abs(rs_cart) < tol] = 0
        qr_cart[np.abs(qr_cart) < tol] = 0
        
        #take the cross product to find the norm
        norm = np.cross(rs_cart,qr_cart)
        norm = norm/sqrt(np.dot(norm,norm))
        #print(rs_cart,qr_cart,norm,self.calculate_miller_indices(norm))
        
        return norm #unit vector in cartesian coords.
    
    def distance_to_plane(self, norm, delta_point_on_plane_point_off_plane):
        #calculate the distance to the plane (defined by a point and normal vector) from a point off the plane
        
        #https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane
        norm2 = (np.dot(norm,norm))
        d = np.dot(delta_point_on_plane_point_off_plane,norm/norm2)#the dot product of the norm_vector and the difference between the two points is the origin-shifted distance projection
        x_dist = norm[0]*d/norm2
        y_dist = norm[1]*d/norm2
        z_dist = norm[2]*d/norm2
        
        return np.sqrt(x_dist**2 + y_dist**2 + z_dist**2)
    
    def structure_factor(self, h,k,l, d):
        #return the structure factor for the unit cell, based on the given miller indices
        #https://en.wikipedia.org/wiki/Structure_factor
        #this calculation should accommodate systematic absence indices based on symmetry
        #http://goodwin.chem.ox.ac.uk/goodwin/TEACHING_files/l7_handout.pdf
        #https://www.xtal.iqfr.csic.es/Cristalografia/parte_07_2_1-en.html
        twotheta = self.th_bragg(d)
        s = 2 * np.sin(twotheta * np.pi / 180 / 2.0) / self.wavelength
        pos_miller = self.calculate_miller_indices(self.unit_cell_atom_positions)
        symbols = self.get_symbols(self.atoms_unit_cell)
        F = 0
        for j in range(len(pos_miller)):
            pos = pos_miller[j]
            f = self.get_waasmaier(symbols[j], s)
            F += f*np.exp(-2*np.pi*1j*(h*pos[0] + k*pos[1] + l*pos[2]))
        F_mag = np.absolute(F)
        #F_phase = np.arctan2(np.imag(F),np.real(F))
        F_thresh = 1e-10
        if(F_mag < F_thresh):
            F_mag = 0
        return F_mag,F
    
    def plane_is_populated(self, h,k,l,d, plot_planes=False):
        #return a boolean indicating if the plane with index h,k,l is populated within the class set of atoms
        hkl = np.array([h,k,l])
        norm_vector = self.calculate_cartesian_plane_norm(hkl)#cartesian normal vector
        populated = False
        #loop over all atoms in the unit cell and check the distance to the plane
        pos = self.atoms_extended_unit_cell.get_positions()#cartesian x,y, and z coordinates of the atoms
        for i in range(len(pos)):
            delta_pos = pos[i] - pos#cartesian difference
            atom_distance_to_plane = self.distance_to_plane(norm_vector,delta_pos)
            
            if(np.any(np.isclose(atom_distance_to_plane, d))):
                populated = True
                
                if(plot_planes):
                    distance_match_index = np.argwhere(np.isclose(atom_distance_to_plane, d))[0]
                    self.plot_plane(hkl, self.calculate_miller_indices(pos[distance_match_index]))
                break
            
        return populated
    
    def repeat_positions_on_unit_cell_edges(self):
        #add atom positions on unit cell edges based on symmetry
        #all of this is done in cartesian coordinates
        lattice_step_100 = self.calculate_cartesian_indices(np.array([1,0,0]))
        lattice_step_010 = self.calculate_cartesian_indices(np.array([0,1,0]))
        lattice_step_001 = self.calculate_cartesian_indices(np.array([0,0,1]))
        lattice_step_110 = self.calculate_cartesian_indices(np.array([1,1,0]))
        lattice_step_011 = self.calculate_cartesian_indices(np.array([0,1,1]))
        lattice_step_101 = self.calculate_cartesian_indices(np.array([1,0,1]))
        lattice_step_111 = self.calculate_cartesian_indices(np.array([1,1,1]))
        
        new_atoms = deepcopy(self.atoms_unit_cell)

        for atom in new_atoms:
            x,y,z = atom.position
            
            if(x==0):
                new_pos = np.array([[x,y,z]+lattice_step_100])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if(y==0):
                new_pos = np.array([[x,y,z]+lattice_step_010])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if(z==0):
                new_pos = np.array([[x,y,z]+lattice_step_001])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if((x==0) & (y==0)):
                new_pos = np.array([[x,y,z]+lattice_step_110])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if((x==0) & (z==0)):
                new_pos = np.array([[x,y,z]+lattice_step_101])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if((z==0) & (y==0)):
                new_pos = np.array([[x,y,z]+lattice_step_011])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
                    
            if((x==0) & (y==0) & (z==0)):
                new_pos = np.array([[x,y,z]+lattice_step_111])
                if not np.any([np.all(new_pos==old_pos) for old_pos in new_atoms.get_positions()]):
                    new_atom = deepcopy(atom)
                    new_atom.position = new_pos
                    new_atoms += new_atom
           
        return new_atoms
    
    def repeat_positions(self,repeat=np.array([1,1,1])):
        #return an atoms object with repetition in the a,b, and c lattice vectors as defined in the repeat inupt array
        new_atoms = deepcopy(self.atoms)
        if(len(repeat)==1):
            repeat = repeat*np.ones(3)
        new_atoms = new_atoms*repeat
        return new_atoms
    
    def plot_lattice(self, fig=None,ax=None):
        #plot lines around the unit cell
        if((fig==None) | (ax==None)):
            fig = plt.figure()
            ax = fig.add_subplot(projection='3d')
            
        p = [
            np.array([0,0,0]),#0
            self.calculate_cartesian_indices(np.array([1,0,0])),#1
            self.calculate_cartesian_indices(np.array([0,1,0])),#2
            self.calculate_cartesian_indices(np.array([0,0,1])),#3
            self.calculate_cartesian_indices(np.array([1,1,0])),#4
            self.calculate_cartesian_indices(np.array([0,1,1])),#5
            self.calculate_cartesian_indices(np.array([1,0,1])),#6
            self.calculate_cartesian_indices(np.array([1,1,1])),#7
            ]
        
        p0_100 = np.array([p[0],p[1]])
        p0_010 = np.array([p[0],p[2]])
        p0_001 = np.array([p[0],p[3]])
        p100_110 = np.array([p[1],p[4]])
        p010_110 = np.array([p[2],p[4]])
        p100_101 = np.array([p[1],p[6]])
        p010_011 = np.array([p[2],p[5]])
        p110_111 = np.array([p[4],p[7]])
        p001_101 = np.array([p[3],p[6]])
        p001_011 = np.array([p[3],p[5]])
        p011_111 = np.array([p[5],p[7]])
        p101_111 = np.array([p[6],p[7]])
        
        def plot_line(line):
            ax.plot(line[:,0],line[:,1],zs=line[:,2],marker='None',linestyle='dashed',color='k',linewidth=1)
            
        plot_line(p0_100)
        plot_line(p0_010)
        plot_line(p100_110)
        plot_line(p010_110)
        plot_line(p0_001)
        plot_line(p100_101)
        plot_line(p010_011)
        plot_line(p110_111)
        plot_line(p001_101)
        plot_line(p001_011)
        plot_line(p101_111)
        plot_line(p011_111)
        
        return fig,ax
    
    def plot_atoms(self, atoms=None, fig=None, ax=None, size_scale=0.5):
        #plot the atoms of the object
        if((fig==None) | (ax==None)):
            fig = plt.figure()
            ax = fig.add_subplot(projection='3d')
        point_size = ax.transData.transform([(0,1),(1,0)]) - ax.transData.transform((0,0))
        if(atoms==None):
            atoms = self.atoms
        #if drawn all together in groups, matplotlib cannot properly redraw top/hidden during rotation
        # symbols_of_all_atoms = np.array([atom.symbol for atom in atoms])#get the array of symbols for all atoms, not including the charge state 
        # unique_symbols = list(set(symbols_of_all_atoms))
        # positions = atoms.get_positions()
        # for i in range(len(unique_symbols)):
            # atom_mask = np.array([symbol == unique_symbols[i] for symbol in symbols_of_all_atoms])
            # number = atomic_numbers[unique_symbols[i]]
            # xc = positions[atom_mask,0]
            # yc = positions[atom_mask,1]
            # zc = positions[atom_mask,2]
            # size = np.pi*np.square(covalent_radii[number])*np.max(point_size[0])*size_scale
            # ax.scatter(xc,yc,zc,color=colors.cpk_colors[number],s=size,edgecolors='k',alpha=1)
        for atom in atoms:
            xc = atom.position[0]
            yc = atom.position[1]
            zc = atom.position[2]
            size = np.pi*np.square(covalent_radii[atom.number])*np.max(point_size[0])*size_scale
            ax.scatter(xc,yc,zc,color=colors.cpk_colors[atom.number],s=size,edgecolors='k')
            
        return fig,ax
    
    def plot_plane(self, miller_indices=np.array([1,0,0]), point=np.array([0,0,0]), atoms=None, fig=None, ax=None, show_axes=False, size_scale=0.25):
        #plot the plane defined by the miller indices and a point in fractional miller indices
        #also plot the atoms and unit cell edges
        
        if((fig==None) | (ax==None)):
            fig = plt.figure()
            ax = fig.add_subplot(projection='3d')
            
        if(atoms==None):
            atoms = self.atoms_extended_unit_cell
        pos = atoms.get_positions() #the cartesian coordinates of the atoms in the object
        xc = pos[:,0]
        yc = pos[:,1]
        zc = pos[:,2]
        
        self.plot_atoms(atoms=atoms, fig=fig, ax=ax, size_scale=size_scale)
        self.plot_lattice(fig,ax)
        
        norm = self.calculate_cartesian_plane_norm(miller_indices)
        pc = self.calculate_cartesian_indices(point)
        d = -np.dot(pc,norm)
        
        #branch depending on whether the plane is parallel to an axis
        if(norm[2] != 0):
            #create x,y
            x, y = np.meshgrid(np.linspace(np.min(xc),np.max(xc),num=2), np.linspace(np.min(yc),np.max(yc),num=2))
            z = (-norm[0] * x - norm[1] * y - d) * 1./norm[2]
        elif(norm[0] != 0):
            y, z = np.meshgrid(np.linspace(np.min(yc),np.max(yc),num=2), np.linspace(np.min(zc),np.max(zc),num=2))
            x = (-norm[2] * z - norm[1] * y - d) * 1./norm[0]
        elif(norm[1] != 0):
            x, z = np.meshgrid(np.linspace(np.min(xc),np.max(xc),num=2), np.linspace(np.min(zc),np.max(zc),num=2))
            y = (-norm[2] * z - norm[0] * x - d) * 1./norm[1]
            
        ax.plot_surface(x,y,z, alpha=0.5)
        
        ax.set_box_aspect((np.ptp(xc),np.ptp(yc),np.ptp(zc)))
        if(show_axes):
            ax.set_xlabel('x [$\AA$]')
            ax.set_ylabel('y [$\AA$]')
        else:
            plt.grid(None)
            plt.axis('off')
        plt.title(self.get_hkl_string(miller_indices, index_type='plane'))
        
        return fig,ax
